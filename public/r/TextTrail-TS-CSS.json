{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "TextTrail-TS-CSS",
  "type": "registry:block",
  "title": "TextTrail",
  "description": "3D trail effect that follows the cursor and changes the text's appearance.",
  "dependencies": [
    "three"
  ],
  "files": [
    {
      "path": "public/ts/default/src/ts-default/TextAnimations/TextTrail/TextTrail.tsx",
      "content": "import React, { useEffect, useRef } from 'react';\nimport {\n  CanvasTexture,\n  Clock,\n  Color,\n  LinearFilter,\n  LinearMipmapLinearFilter,\n  Mesh,\n  OrthographicCamera,\n  PlaneGeometry,\n  Scene,\n  ShaderMaterial,\n  Vector2,\n  Vector3,\n  WebGLRenderer,\n  WebGLRenderTarget\n} from 'three';\n\nimport './TextTrail.css';\n\nconst hexToRgb = (hex: string): [number, number, number] => {\n  let h = hex.replace('#', '');\n  if (h.length === 3)\n    h = h\n      .split('')\n      .map(c => c + c)\n      .join('');\n  const n = parseInt(h, 16);\n  return [(n >> 16) & 255, (n >> 8) & 255, n & 255];\n};\nconst loadFont = async (fam: string) => {\n  if ('fonts' in document) await document.fonts.load(`64px \"${fam}\"`);\n};\n\nconst BASE_VERT = `\nvarying vec2 v_uv;\nvoid main(){gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);v_uv=uv;}`;\n\nconst SIMPLEX = `\nvec3 mod289(vec3 x){return x-floor(x*(1./289.))*289.;}\nvec4 mod289(vec4 x){return x-floor(x*(1./289.))*289.;}\nvec4 permute(vec4 x){return mod289(((x*34.)+1.)*x);}\nfloat snoise3(vec3 v){\n  const vec2 C=vec2(1./6.,1./3.);\n  const vec4 D=vec4(0.,.5,1.,2.);\n  vec3 i=floor(v+dot(v,C.yyy));\n  vec3 x0=v-i+dot(i,C.xxx);\n  vec3 g=step(x0.yzx,x0.xyz);\n  vec3 l=1.-g;\n  vec3 i1=min(g.xyz,l.zxy);\n  vec3 i2=max(g.xyz,l.zxy);\n  vec3 x1=x0-i1+C.xxx;\n  vec3 x2=x0-i2+C.yyy;\n  vec3 x3=x0-D.yyy;\n  i=mod289(i);\n  vec4 p=permute(permute(permute(i.z+vec4(0.,i1.z,i2.z,1.))+i.y+vec4(0.,i1.y,i2.y,1.))+i.x+vec4(0.,i1.x,i2.x,1.));\n  float n_=1./7.; vec3 ns=n_*D.wyz-D.xzx;\n  vec4 j=p-49.*floor(p*ns.z*ns.z);\n  vec4 x_=floor(j*ns.z);\n  vec4 y_=floor(j-7.*x_);\n  vec4 x=x_*ns.x+ns.yyyy;\n  vec4 y=y_*ns.x+ns.yyyy;\n  vec4 h=1.-abs(x)-abs(y);\n  vec4 b0=vec4(x.xy,y.xy);\n  vec4 b1=vec4(x.zw,y.zw);\n  vec4 s0=floor(b0)*2.+1.;\n  vec4 s1=floor(b1)*2.+1.;\n  vec4 sh=-step(h,vec4(0.));\n  vec4 a0=b0.xzyw+s0.xzyw*sh.xxyy;\n  vec4 a1=b1.xzyw+s1.xzyw*sh.zzww;\n  vec3 p0=vec3(a0.xy,h.x);\n  vec3 p1=vec3(a0.zw,h.y);\n  vec3 p2=vec3(a1.xy,h.z);\n  vec3 p3=vec3(a1.zw,h.w);\n  vec4 norm=inversesqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));\n  p0*=norm.x; p1*=norm.y; p2*=norm.z; p3*=norm.w;\n  vec4 m=max(.6-vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)),0.);\n  m*=m;\n  return 42.*dot(m*m,vec4(dot(p0,x0),dot(p1,x1),dot(p2,x2),dot(p3,x3)));\n}`;\n\nconst PERSIST_FRAG = `\nuniform sampler2D sampler;\nuniform float time;\nuniform vec2 mousePos;\nuniform float noiseFactor,noiseScale,rgbPersistFactor,alphaPersistFactor;\nvarying vec2 v_uv;\n${SIMPLEX}\nvoid main(){\n  float a=snoise3(vec3(v_uv*noiseFactor,time*.1))*noiseScale;\n  float b=snoise3(vec3(v_uv*noiseFactor,time*.1+100.))*noiseScale;\n  vec4 t=texture2D(sampler,v_uv+vec2(a,b)+mousePos*.005);\n  gl_FragColor=vec4(t.xyz*rgbPersistFactor,alphaPersistFactor);\n}`;\n\nconst TEXT_FRAG = `\nuniform sampler2D sampler;uniform vec3 color;varying vec2 v_uv;\nvoid main(){\n  vec4 t=texture2D(sampler,v_uv);\n  float alpha=smoothstep(0.1,0.9,t.a);\n  if(alpha<0.01)discard;\n  gl_FragColor=vec4(color,alpha);\n}`;\n\nexport interface TextTrailProps {\n  text?: string;\n  fontFamily?: string;\n  fontWeight?: string | number;\n  noiseFactor?: number;\n  noiseScale?: number;\n  rgbPersistFactor?: number;\n  alphaPersistFactor?: number;\n  animateColor?: boolean;\n  startColor?: string;\n  textColor?: string;\n  backgroundColor?: number | string;\n  colorCycleInterval?: number;\n  supersample?: number;\n}\n\nconst TextTrail: React.FC<TextTrailProps> = ({\n  text = 'Trail',\n  fontFamily = 'Figtree',\n  fontWeight = '900',\n  noiseFactor = 1,\n  noiseScale = 0.0005,\n  rgbPersistFactor = 0.98,\n  alphaPersistFactor = 0.95,\n  animateColor = false,\n  startColor = '#ffffff',\n  textColor = '#ffffff',\n  backgroundColor = 0x271e37,\n  colorCycleInterval = 3000,\n  supersample = 2\n}) => {\n  const ref = useRef<HTMLDivElement>(null);\n\n  const persistColor = useRef<[number, number, number]>(\n    hexToRgb(textColor || startColor).map(c => c / 255) as [number, number, number]\n  );\n  const targetColor = useRef<[number, number, number]>([...persistColor.current]);\n\n  useEffect(() => {\n    if (!ref.current) return;\n\n    const size = () => ({\n      w: ref.current!.clientWidth,\n      h: ref.current!.clientHeight\n    });\n    let { w, h } = size();\n\n    const renderer = new WebGLRenderer({ antialias: true });\n    renderer.setClearColor(new Color(backgroundColor as any), 1);\n    renderer.setPixelRatio(window.devicePixelRatio || 1);\n    renderer.setSize(w, h);\n    ref.current.appendChild(renderer.domElement);\n\n    const scene = new Scene();\n    const fluidScene = new Scene();\n    const clock = new Clock();\n    const cam = new OrthographicCamera(-w / 2, w / 2, h / 2, -h / 2, 0.1, 10);\n    cam.position.z = 1;\n\n    let rt0 = new WebGLRenderTarget(w, h);\n    let rt1 = rt0.clone();\n\n    const quadMat = new ShaderMaterial({\n      uniforms: {\n        sampler: { value: null },\n        time: { value: 0 },\n        mousePos: { value: new Vector2(-1, 1) },\n        noiseFactor: { value: noiseFactor },\n        noiseScale: { value: noiseScale },\n        rgbPersistFactor: { value: rgbPersistFactor },\n        alphaPersistFactor: { value: alphaPersistFactor }\n      },\n      vertexShader: BASE_VERT,\n      fragmentShader: PERSIST_FRAG,\n      transparent: true\n    });\n    const quad = new Mesh(new PlaneGeometry(w, h), quadMat);\n    fluidScene.add(quad);\n\n    const labelMat = new ShaderMaterial({\n      uniforms: {\n        sampler: { value: null },\n        color: { value: new Vector3(...persistColor.current) }\n      },\n      vertexShader: BASE_VERT,\n      fragmentShader: TEXT_FRAG,\n      transparent: true\n    });\n    const label = new Mesh(new PlaneGeometry(Math.min(w, h), Math.min(w, h)), labelMat);\n    scene.add(label);\n\n    const texCanvas = document.createElement('canvas');\n    const ctx = texCanvas.getContext('2d', {\n      alpha: true,\n      colorSpace: 'srgb'\n    })!;\n    const drawText = () => {\n      const max = Math.min(renderer.capabilities.maxTextureSize, 4096);\n      const pixelRatio = (window.devicePixelRatio || 1) * supersample;\n      const canvasSize = max * pixelRatio;\n      texCanvas.width = canvasSize;\n      texCanvas.height = canvasSize;\n      texCanvas.style.width = `${max}px`;\n      texCanvas.style.height = `${max}px`;\n\n      ctx.setTransform(1, 0, 0, 1, 0, 0);\n      ctx.scale(pixelRatio, pixelRatio);\n      ctx.clearRect(0, 0, max, max);\n      ctx.imageSmoothingEnabled = true;\n      ctx.imageSmoothingQuality = 'high';\n      ctx.shadowColor = 'rgba(255,255,255,0.3)';\n      ctx.shadowBlur = 2;\n      ctx.fillStyle = '#fff';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n\n      const refSize = 250;\n      ctx.font = `${fontWeight} ${refSize}px ${fontFamily}`;\n      const width = ctx.measureText(text).width;\n      ctx.font = `${fontWeight} ${(refSize * max) / width}px ${fontFamily}`;\n\n      const cx = max / 2,\n        cy = max / 2;\n      const offs = [\n        [0, 0],\n        [0.1, 0],\n        [-0.1, 0],\n        [0, 0.1],\n        [0, -0.1],\n        [0.1, 0.1],\n        [-0.1, -0.1],\n        [0.1, -0.1],\n        [-0.1, 0.1]\n      ];\n      ctx.globalAlpha = 1 / offs.length;\n      offs.forEach(([dx, dy]) => ctx.fillText(text, cx + dx, cy + dy));\n      ctx.globalAlpha = 1;\n\n      const tex = new CanvasTexture(texCanvas);\n      tex.generateMipmaps = true;\n      tex.minFilter = LinearMipmapLinearFilter;\n      tex.magFilter = LinearFilter;\n      labelMat.uniforms.sampler.value = tex;\n    };\n    loadFont(fontFamily).finally(drawText);\n\n    const mouse = [0, 0],\n      target = [0, 0];\n    const onMove = (e: PointerEvent) => {\n      const r = ref.current!.getBoundingClientRect();\n      target[0] = ((e.clientX - r.left) / r.width) * 2 - 1;\n      target[1] = ((r.top + r.height - e.clientY) / r.height) * 2 - 1;\n    };\n    ref.current.addEventListener('pointermove', onMove);\n\n    const ro = new ResizeObserver(() => {\n      ({ w, h } = size());\n      renderer.setSize(w, h);\n      cam.left = -w / 2;\n      cam.right = w / 2;\n      cam.top = h / 2;\n      cam.bottom = -h / 2;\n      cam.updateProjectionMatrix();\n      quad.geometry.dispose();\n      quad.geometry = new PlaneGeometry(w, h);\n      rt0.setSize(w, h);\n      rt1.setSize(w, h);\n      label.geometry.dispose();\n      label.geometry = new PlaneGeometry(Math.min(w, h), Math.min(w, h));\n    });\n    ro.observe(ref.current);\n\n    const timer = setInterval(() => {\n      if (!textColor) {\n        targetColor.current = [Math.random(), Math.random(), Math.random()];\n      }\n    }, colorCycleInterval);\n\n    renderer.setAnimationLoop(() => {\n      const dt = clock.getDelta();\n      if (animateColor && !textColor) {\n        for (let i = 0; i < 3; i++) persistColor.current[i] += (targetColor.current[i] - persistColor.current[i]) * dt;\n      }\n      const speed = dt * 5;\n      mouse[0] += (target[0] - mouse[0]) * speed;\n      mouse[1] += (target[1] - mouse[1]) * speed;\n\n      quadMat.uniforms.mousePos.value.set(mouse[0], mouse[1]);\n      quadMat.uniforms.sampler.value = rt1.texture;\n      quadMat.uniforms.time.value = clock.getElapsedTime();\n      labelMat.uniforms.color.value.set(...persistColor.current);\n\n      renderer.autoClearColor = false;\n      renderer.setRenderTarget(rt0);\n      renderer.clearColor();\n      renderer.render(fluidScene, cam);\n      renderer.render(scene, cam);\n      renderer.setRenderTarget(null);\n      renderer.render(fluidScene, cam);\n      renderer.render(scene, cam);\n      [rt0, rt1] = [rt1, rt0];\n    });\n\n    return () => {\n      renderer.setAnimationLoop(null);\n      clearInterval(timer);\n      ref.current?.removeEventListener('pointermove', onMove);\n      ro.disconnect();\n      ref.current?.removeChild(renderer.domElement);\n      renderer.dispose();\n      rt0.dispose();\n      rt1.dispose();\n      quadMat.dispose();\n      quad.geometry.dispose();\n      labelMat.dispose();\n      label.geometry.dispose();\n    };\n  }, [\n    text,\n    fontFamily,\n    fontWeight,\n    noiseFactor,\n    noiseScale,\n    rgbPersistFactor,\n    alphaPersistFactor,\n    animateColor,\n    startColor,\n    textColor,\n    backgroundColor,\n    colorCycleInterval,\n    supersample\n  ]);\n\n  return <div ref={ref} className=\"text-trail\" />;\n};\n\nexport default TextTrail;\n",
      "type": "registry:component"
    },
    {
      "path": "public/ts/default/src/ts-default/TextAnimations/TextTrail/TextTrail.css",
      "content": ".text-trail {\n  width: 100%;\n  height: 100%;\n}\n",
      "type": "registry:item"
    }
  ]
}