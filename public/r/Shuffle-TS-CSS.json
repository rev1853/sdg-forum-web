{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "Shuffle-TS-CSS",
  "type": "registry:block",
  "title": "Shuffle",
  "description": "Animated text reveal where characters shuffle before settling.",
  "dependencies": [
    "@gsap/react",
    "gsap"
  ],
  "files": [
    {
      "path": "public/ts/default/src/ts-default/TextAnimations/Shuffle/Shuffle.tsx",
      "content": "import React, { useRef, useEffect, useState } from 'react';\nimport { gsap } from 'gsap';\nimport { ScrollTrigger } from 'gsap/ScrollTrigger';\nimport { SplitText as GSAPSplitText } from 'gsap/SplitText';\nimport { useGSAP } from '@gsap/react';\nimport './Shuffle.css';\n\ngsap.registerPlugin(ScrollTrigger, GSAPSplitText, useGSAP);\n\nexport interface ShuffleProps {\n  text: string;\n  className?: string;\n  style?: React.CSSProperties;\n  shuffleDirection?: 'left' | 'right';\n  duration?: number;\n  maxDelay?: number;\n  ease?: string | ((t: number) => number);\n  threshold?: number;\n  rootMargin?: string;\n  tag?: 'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6' | 'p' | 'span';\n  textAlign?: React.CSSProperties['textAlign'];\n  onShuffleComplete?: () => void;\n  shuffleTimes?: number;\n  animationMode?: 'random' | 'evenodd';\n  loop?: boolean;\n  loopDelay?: number;\n  stagger?: number;\n  scrambleCharset?: string;\n  colorFrom?: string;\n  colorTo?: string;\n  triggerOnce?: boolean;\n  respectReducedMotion?: boolean;\n  triggerOnHover?: boolean;\n}\n\nconst Shuffle: React.FC<ShuffleProps> = ({\n  text,\n  className = '',\n  style = {},\n  shuffleDirection = 'right',\n  duration = 0.35,\n  maxDelay = 0,\n  ease = 'power3.out',\n  threshold = 0.1,\n  rootMargin = '-100px',\n  tag = 'p',\n  textAlign = 'center',\n  onShuffleComplete,\n  shuffleTimes = 1,\n  animationMode = 'evenodd',\n  loop = false,\n  loopDelay = 0,\n  stagger = 0.03,\n  scrambleCharset = '',\n  colorFrom,\n  colorTo,\n  triggerOnce = true,\n  respectReducedMotion = true,\n  triggerOnHover = true\n}) => {\n  const ref = useRef<HTMLElement>(null);\n  const [fontsLoaded, setFontsLoaded] = useState(false);\n  const [ready, setReady] = useState(false);\n\n  const splitRef = useRef<GSAPSplitText | null>(null);\n  const wrappersRef = useRef<HTMLElement[]>([]);\n  const tlRef = useRef<gsap.core.Timeline | null>(null);\n  const playingRef = useRef(false);\n  const hoverHandlerRef = useRef<((e: Event) => void) | null>(null);\n\n  useEffect(() => {\n    if ('fonts' in document) {\n      if (document.fonts.status === 'loaded') setFontsLoaded(true);\n      else document.fonts.ready.then(() => setFontsLoaded(true));\n    } else setFontsLoaded(true);\n  }, []);\n\n  useGSAP(\n    () => {\n      if (!ref.current || !text || !fontsLoaded) return;\n      if (respectReducedMotion && window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches) {\n        onShuffleComplete?.();\n        return;\n      }\n\n      const el = ref.current as HTMLElement;\n\n      const startPct = (1 - threshold) * 100;\n      const mm = /^(-?\\d+(?:\\.\\d+)?)(px|em|rem|%)?$/.exec(rootMargin || '');\n      const mv = mm ? parseFloat(mm[1]) : 0;\n      const mu = mm ? mm[2] || 'px' : 'px';\n      const sign = mv === 0 ? '' : mv < 0 ? `-=${Math.abs(mv)}${mu}` : `+=${mv}${mu}`;\n      const start = `top ${startPct}%${sign}`;\n\n      const removeHover = () => {\n        if (hoverHandlerRef.current && ref.current) {\n          ref.current.removeEventListener('mouseenter', hoverHandlerRef.current);\n          hoverHandlerRef.current = null;\n        }\n      };\n\n      const teardown = () => {\n        if (tlRef.current) {\n          tlRef.current.kill();\n          tlRef.current = null;\n        }\n        if (wrappersRef.current.length) {\n          wrappersRef.current.forEach(wrap => {\n            const inner = wrap.firstElementChild as HTMLElement | null;\n            const orig = inner?.querySelector('[data-orig=\"1\"]') as HTMLElement | null;\n            if (orig && wrap.parentNode) wrap.parentNode.replaceChild(orig, wrap);\n          });\n          wrappersRef.current = [];\n        }\n        try {\n          splitRef.current?.revert();\n        } catch {}\n        splitRef.current = null;\n        playingRef.current = false;\n      };\n\n      const build = () => {\n        teardown();\n\n        splitRef.current = new GSAPSplitText(el, {\n          type: 'chars',\n          charsClass: 'shuffle-char',\n          wordsClass: 'shuffle-word',\n          linesClass: 'shuffle-line',\n          smartWrap: true,\n          reduceWhiteSpace: false\n        });\n\n        const chars = (splitRef.current.chars || []) as HTMLElement[];\n        wrappersRef.current = [];\n\n        const rolls = Math.max(1, Math.floor(shuffleTimes));\n        const rand = (set: string) => set.charAt(Math.floor(Math.random() * set.length)) || '';\n\n        chars.forEach(ch => {\n          const parent = ch.parentElement;\n          if (!parent) return;\n\n          const w = ch.getBoundingClientRect().width;\n          if (!w) return;\n\n          const wrap = document.createElement('span');\n          Object.assign(wrap.style, {\n            display: 'inline-block',\n            overflow: 'hidden',\n            width: w + 'px',\n            verticalAlign: 'baseline'\n          });\n\n          const inner = document.createElement('span');\n          Object.assign(inner.style, {\n            display: 'inline-block',\n            whiteSpace: 'nowrap',\n            willChange: 'transform'\n          });\n\n          parent.insertBefore(wrap, ch);\n          wrap.appendChild(inner);\n\n          const firstOrig = ch.cloneNode(true) as HTMLElement;\n          Object.assign(firstOrig.style, { display: 'inline-block', width: w + 'px', textAlign: 'center' });\n\n          ch.setAttribute('data-orig', '1');\n          Object.assign(ch.style, { display: 'inline-block', width: w + 'px', textAlign: 'center' });\n\n          inner.appendChild(firstOrig);\n          for (let k = 0; k < rolls; k++) {\n            const c = ch.cloneNode(true) as HTMLElement;\n            if (scrambleCharset) c.textContent = rand(scrambleCharset);\n            Object.assign(c.style, { display: 'inline-block', width: w + 'px', textAlign: 'center' });\n            inner.appendChild(c);\n          }\n          inner.appendChild(ch);\n\n          const steps = rolls + 1;\n          let startX = 0;\n          let finalX = -steps * w;\n          if (shuffleDirection === 'right') {\n            const firstCopy = inner.firstElementChild as HTMLElement | null;\n            const real = inner.lastElementChild as HTMLElement | null;\n            if (real) inner.insertBefore(real, inner.firstChild);\n            if (firstCopy) inner.appendChild(firstCopy);\n            startX = -steps * w;\n            finalX = 0;\n          }\n\n          gsap.set(inner, { x: startX, force3D: true });\n          if (colorFrom) (inner.style as any).color = colorFrom;\n\n          inner.setAttribute('data-final-x', String(finalX));\n          inner.setAttribute('data-start-x', String(startX));\n\n          wrappersRef.current.push(wrap);\n        });\n      };\n\n      const inners = () => wrappersRef.current.map(w => w.firstElementChild as HTMLElement);\n\n      const randomizeScrambles = () => {\n        if (!scrambleCharset) return;\n        wrappersRef.current.forEach(w => {\n          const strip = w.firstElementChild as HTMLElement;\n          if (!strip) return;\n          const kids = Array.from(strip.children) as HTMLElement[];\n          for (let i = 1; i < kids.length - 1; i++) {\n            kids[i].textContent = scrambleCharset.charAt(Math.floor(Math.random() * scrambleCharset.length));\n          }\n        });\n      };\n\n      const cleanupToStill = () => {\n        wrappersRef.current.forEach(w => {\n          const strip = w.firstElementChild as HTMLElement;\n          if (!strip) return;\n          const real = strip.querySelector('[data-orig=\"1\"]') as HTMLElement | null;\n          if (!real) return;\n          strip.replaceChildren(real);\n          strip.style.transform = 'none';\n          strip.style.willChange = 'auto';\n        });\n      };\n\n      const play = () => {\n        const strips = inners();\n        if (!strips.length) return;\n\n        playingRef.current = true;\n\n        const tl = gsap.timeline({\n          smoothChildTiming: true,\n          repeat: loop ? -1 : 0,\n          repeatDelay: loop ? loopDelay : 0,\n          onRepeat: () => {\n            if (scrambleCharset) randomizeScrambles();\n            gsap.set(strips, { x: (i, t: HTMLElement) => parseFloat(t.getAttribute('data-start-x') || '0') });\n            onShuffleComplete?.();\n          },\n          onComplete: () => {\n            playingRef.current = false;\n            if (!loop) {\n              cleanupToStill();\n              if (colorTo) gsap.set(strips, { color: colorTo });\n              onShuffleComplete?.();\n              armHover();\n            }\n          }\n        });\n\n        const addTween = (targets: HTMLElement[], at: number) => {\n          tl.to(\n            targets,\n            {\n              x: (i, t: HTMLElement) => parseFloat(t.getAttribute('data-final-x') || '0'),\n              duration,\n              ease,\n              force3D: true,\n              stagger: animationMode === 'evenodd' ? stagger : 0\n            },\n            at\n          );\n          if (colorFrom && colorTo) {\n            tl.to(targets, { color: colorTo, duration, ease }, at);\n          }\n        };\n\n        if (animationMode === 'evenodd') {\n          const odd = strips.filter((_, i) => i % 2 === 1);\n          const even = strips.filter((_, i) => i % 2 === 0);\n          const oddTotal = duration + Math.max(0, odd.length - 1) * stagger;\n          const evenStart = odd.length ? oddTotal * 0.7 : 0;\n          if (odd.length) addTween(odd, 0);\n          if (even.length) addTween(even, evenStart);\n        } else {\n          strips.forEach(strip => {\n            const d = Math.random() * maxDelay;\n            tl.to(\n              strip,\n              {\n                x: parseFloat(strip.getAttribute('data-final-x') || '0'),\n                duration,\n                ease,\n                force3D: true\n              },\n              d\n            );\n            if (colorFrom && colorTo) tl.fromTo(strip, { color: colorFrom }, { color: colorTo, duration, ease }, d);\n          });\n        }\n\n        tlRef.current = tl;\n      };\n\n      const armHover = () => {\n        if (!triggerOnHover || !ref.current) return;\n        removeHover();\n        const handler = () => {\n          if (playingRef.current) return;\n          build();\n          if (scrambleCharset) randomizeScrambles();\n          play();\n        };\n        hoverHandlerRef.current = handler;\n        ref.current.addEventListener('mouseenter', handler);\n      };\n\n      const create = () => {\n        build();\n        if (scrambleCharset) randomizeScrambles();\n        play();\n        armHover();\n        setReady(true);\n      };\n\n      const st = ScrollTrigger.create({\n        trigger: el,\n        start,\n        once: triggerOnce,\n        onEnter: create\n      });\n\n      return () => {\n        st.kill();\n        removeHover();\n        teardown();\n        setReady(false);\n      };\n    },\n    {\n      dependencies: [\n        text,\n        duration,\n        maxDelay,\n        ease,\n        threshold,\n        rootMargin,\n        fontsLoaded,\n        shuffleDirection,\n        shuffleTimes,\n        animationMode,\n        loop,\n        loopDelay,\n        stagger,\n        scrambleCharset,\n        colorFrom,\n        colorTo,\n        triggerOnce,\n        respectReducedMotion,\n        triggerOnHover\n      ],\n      scope: ref\n    }\n  );\n\n  const commonStyle: React.CSSProperties = { textAlign, ...style };\n  const classes = `shuffle-parent ${ready ? 'is-ready' : ''} ${className}`;\n  const Tag = (tag || 'p') as keyof JSX.IntrinsicElements;\n  return React.createElement(Tag, { ref: ref as any, className: classes, style: commonStyle }, text);\n};\n\nexport default Shuffle;\n",
      "type": "registry:component"
    },
    {
      "path": "public/ts/default/src/ts-default/TextAnimations/Shuffle/Shuffle.css",
      "content": ".shuffle-parent {\n  display: inline-block;\n  white-space: normal;\n  word-wrap: break-word;\n  will-change: transform;\n  line-height: 1; /* keep line height consistent before/after split to avoid jump */\n  font-size: 4rem;\n  font-family: 'Press Start 2P', sans-serif;\n  text-transform: uppercase;\n  visibility: hidden; /* hidden until initialized to avoid flash/jump */\n}\n\n.shuffle-parent.is-ready {\n  visibility: visible;\n}\n\n.shuffle-char-wrapper {\n  display: inline-block;\n  overflow: hidden;\n  vertical-align: baseline;\n  position: relative;\n}\n\n.shuffle-char-wrapper > span {\n  display: inline-flex;\n  will-change: transform;\n}\n\n.shuffle-char {\n  line-height: 1;\n  display: inline-block;\n  text-align: center;\n}\n",
      "type": "registry:item"
    }
  ]
}