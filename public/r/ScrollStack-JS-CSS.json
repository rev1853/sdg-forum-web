{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "ScrollStack-JS-CSS",
  "type": "registry:block",
  "title": "ScrollStack",
  "description": "Overlapping card stack reveals on scroll with depth layering.",
  "dependencies": [
    "lenis"
  ],
  "files": [
    {
      "path": "public/default/src/content/Components/ScrollStack/ScrollStack.jsx",
      "content": "import { useLayoutEffect, useRef, useCallback } from 'react';\nimport Lenis from 'lenis';\nimport './ScrollStack.css';\n\nexport const ScrollStackItem = ({ children, itemClassName = '' }) => (\n  <div className={`scroll-stack-card ${itemClassName}`.trim()}>{children}</div>\n);\n\nconst ScrollStack = ({\n  children,\n  className = '',\n  itemDistance = 100,\n  itemScale = 0.03,\n  itemStackDistance = 30,\n  stackPosition = '20%',\n  scaleEndPosition = '10%',\n  baseScale = 0.85,\n  scaleDuration = 0.5,\n  rotationAmount = 0,\n  blurAmount = 0,\n  useWindowScroll = false,\n  onStackComplete\n}) => {\n  const scrollerRef = useRef(null);\n  const stackCompletedRef = useRef(false);\n  const animationFrameRef = useRef(null);\n  const lenisRef = useRef(null);\n  const cardsRef = useRef([]);\n  const lastTransformsRef = useRef(new Map());\n  const isUpdatingRef = useRef(false);\n\n  const calculateProgress = useCallback((scrollTop, start, end) => {\n    if (scrollTop < start) return 0;\n    if (scrollTop > end) return 1;\n    return (scrollTop - start) / (end - start);\n  }, []);\n\n  const parsePercentage = useCallback((value, containerHeight) => {\n    if (typeof value === 'string' && value.includes('%')) {\n      return (parseFloat(value) / 100) * containerHeight;\n    }\n    return parseFloat(value);\n  }, []);\n\n  const getScrollData = useCallback(() => {\n    if (useWindowScroll) {\n      return {\n        scrollTop: window.scrollY,\n        containerHeight: window.innerHeight,\n        scrollContainer: document.documentElement\n      };\n    } else {\n      const scroller = scrollerRef.current;\n      return {\n        scrollTop: scroller.scrollTop,\n        containerHeight: scroller.clientHeight,\n        scrollContainer: scroller\n      };\n    }\n  }, [useWindowScroll]);\n\n  const getElementOffset = useCallback(\n    element => {\n      if (useWindowScroll) {\n        const rect = element.getBoundingClientRect();\n        return rect.top + window.scrollY;\n      } else {\n        return element.offsetTop;\n      }\n    },\n    [useWindowScroll]\n  );\n\n  const updateCardTransforms = useCallback(() => {\n    if (!cardsRef.current.length || isUpdatingRef.current) return;\n\n    isUpdatingRef.current = true;\n\n    const { scrollTop, containerHeight, scrollContainer } = getScrollData();\n    const stackPositionPx = parsePercentage(stackPosition, containerHeight);\n    const scaleEndPositionPx = parsePercentage(scaleEndPosition, containerHeight);\n\n    const endElement = useWindowScroll\n      ? document.querySelector('.scroll-stack-end')\n      : scrollerRef.current?.querySelector('.scroll-stack-end');\n\n    const endElementTop = endElement ? getElementOffset(endElement) : 0;\n\n    cardsRef.current.forEach((card, i) => {\n      if (!card) return;\n\n      const cardTop = getElementOffset(card);\n      const triggerStart = cardTop - stackPositionPx - itemStackDistance * i;\n      const triggerEnd = cardTop - scaleEndPositionPx;\n      const pinStart = cardTop - stackPositionPx - itemStackDistance * i;\n      const pinEnd = endElementTop - containerHeight / 2;\n\n      const scaleProgress = calculateProgress(scrollTop, triggerStart, triggerEnd);\n      const targetScale = baseScale + i * itemScale;\n      const scale = 1 - scaleProgress * (1 - targetScale);\n      const rotation = rotationAmount ? i * rotationAmount * scaleProgress : 0;\n\n      let blur = 0;\n      if (blurAmount) {\n        let topCardIndex = 0;\n        for (let j = 0; j < cardsRef.current.length; j++) {\n          const jCardTop = getElementOffset(cardsRef.current[j]);\n          const jTriggerStart = jCardTop - stackPositionPx - itemStackDistance * j;\n          if (scrollTop >= jTriggerStart) {\n            topCardIndex = j;\n          }\n        }\n\n        if (i < topCardIndex) {\n          const depthInStack = topCardIndex - i;\n          blur = Math.max(0, depthInStack * blurAmount);\n        }\n      }\n\n      let translateY = 0;\n      const isPinned = scrollTop >= pinStart && scrollTop <= pinEnd;\n\n      if (isPinned) {\n        translateY = scrollTop - cardTop + stackPositionPx + itemStackDistance * i;\n      } else if (scrollTop > pinEnd) {\n        translateY = pinEnd - cardTop + stackPositionPx + itemStackDistance * i;\n      }\n\n      const newTransform = {\n        translateY: Math.round(translateY * 100) / 100,\n        scale: Math.round(scale * 1000) / 1000,\n        rotation: Math.round(rotation * 100) / 100,\n        blur: Math.round(blur * 100) / 100\n      };\n\n      const lastTransform = lastTransformsRef.current.get(i);\n      const hasChanged =\n        !lastTransform ||\n        Math.abs(lastTransform.translateY - newTransform.translateY) > 0.1 ||\n        Math.abs(lastTransform.scale - newTransform.scale) > 0.001 ||\n        Math.abs(lastTransform.rotation - newTransform.rotation) > 0.1 ||\n        Math.abs(lastTransform.blur - newTransform.blur) > 0.1;\n\n      if (hasChanged) {\n        const transform = `translate3d(0, ${newTransform.translateY}px, 0) scale(${newTransform.scale}) rotate(${newTransform.rotation}deg)`;\n        const filter = newTransform.blur > 0 ? `blur(${newTransform.blur}px)` : '';\n\n        card.style.transform = transform;\n        card.style.filter = filter;\n\n        lastTransformsRef.current.set(i, newTransform);\n      }\n\n      if (i === cardsRef.current.length - 1) {\n        const isInView = scrollTop >= pinStart && scrollTop <= pinEnd;\n        if (isInView && !stackCompletedRef.current) {\n          stackCompletedRef.current = true;\n          onStackComplete?.();\n        } else if (!isInView && stackCompletedRef.current) {\n          stackCompletedRef.current = false;\n        }\n      }\n    });\n\n    isUpdatingRef.current = false;\n  }, [\n    itemScale,\n    itemStackDistance,\n    stackPosition,\n    scaleEndPosition,\n    baseScale,\n    rotationAmount,\n    blurAmount,\n    useWindowScroll,\n    onStackComplete,\n    calculateProgress,\n    parsePercentage,\n    getScrollData,\n    getElementOffset\n  ]);\n\n  const handleScroll = useCallback(() => {\n    updateCardTransforms();\n  }, [updateCardTransforms]);\n\n  const setupLenis = useCallback(() => {\n    if (useWindowScroll) {\n      const lenis = new Lenis({\n        duration: 1.2,\n        easing: t => Math.min(1, 1.001 - Math.pow(2, -10 * t)),\n        smoothWheel: true,\n        touchMultiplier: 2,\n        infinite: false,\n        wheelMultiplier: 1,\n        lerp: 0.1,\n        syncTouch: true,\n        syncTouchLerp: 0.075\n      });\n\n      lenis.on('scroll', handleScroll);\n\n      const raf = time => {\n        lenis.raf(time);\n        animationFrameRef.current = requestAnimationFrame(raf);\n      };\n      animationFrameRef.current = requestAnimationFrame(raf);\n\n      lenisRef.current = lenis;\n      return lenis;\n    } else {\n      const scroller = scrollerRef.current;\n      if (!scroller) return;\n\n      const lenis = new Lenis({\n        wrapper: scroller,\n        content: scroller.querySelector('.scroll-stack-inner'),\n        duration: 1.2,\n        easing: t => Math.min(1, 1.001 - Math.pow(2, -10 * t)),\n        smoothWheel: true,\n        touchMultiplier: 2,\n        infinite: false,\n        gestureOrientationHandler: true,\n        normalizeWheel: true,\n        wheelMultiplier: 1,\n        touchInertiaMultiplier: 35,\n        lerp: 0.1,\n        syncTouch: true,\n        syncTouchLerp: 0.075,\n        touchInertia: 0.6\n      });\n\n      lenis.on('scroll', handleScroll);\n\n      const raf = time => {\n        lenis.raf(time);\n        animationFrameRef.current = requestAnimationFrame(raf);\n      };\n      animationFrameRef.current = requestAnimationFrame(raf);\n\n      lenisRef.current = lenis;\n      return lenis;\n    }\n  }, [handleScroll, useWindowScroll]);\n\n  useLayoutEffect(() => {\n    const scroller = scrollerRef.current;\n    if (!scroller) return;\n\n    const cards = Array.from(\n      useWindowScroll\n        ? document.querySelectorAll('.scroll-stack-card')\n        : scroller.querySelectorAll('.scroll-stack-card')\n    );\n\n    cardsRef.current = cards;\n    const transformsCache = lastTransformsRef.current;\n\n    cards.forEach((card, i) => {\n      if (i < cards.length - 1) {\n        card.style.marginBottom = `${itemDistance}px`;\n      }\n      card.style.willChange = 'transform, filter';\n      card.style.transformOrigin = 'top center';\n      card.style.backfaceVisibility = 'hidden';\n      card.style.transform = 'translateZ(0)';\n      card.style.webkitTransform = 'translateZ(0)';\n      card.style.perspective = '1000px';\n      card.style.webkitPerspective = '1000px';\n    });\n\n    setupLenis();\n\n    updateCardTransforms();\n\n    return () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n      if (lenisRef.current) {\n        lenisRef.current.destroy();\n      }\n      stackCompletedRef.current = false;\n      cardsRef.current = [];\n      transformsCache.clear();\n      isUpdatingRef.current = false;\n    };\n  }, [\n    itemDistance,\n    itemScale,\n    itemStackDistance,\n    stackPosition,\n    scaleEndPosition,\n    baseScale,\n    scaleDuration,\n    rotationAmount,\n    blurAmount,\n    useWindowScroll,\n    onStackComplete,\n    setupLenis,\n    updateCardTransforms\n  ]);\n\n  return (\n    <div className={`scroll-stack-scroller ${className}`.trim()} ref={scrollerRef}>\n      <div className=\"scroll-stack-inner\">\n        {children}\n        {/* Spacer so the last pin can release cleanly */}\n        <div className=\"scroll-stack-end\" />\n      </div>\n    </div>\n  );\n};\n\nexport default ScrollStack;\n",
      "type": "registry:component"
    },
    {
      "path": "public/default/src/content/Components/ScrollStack/ScrollStack.css",
      "content": ".scroll-stack-scroller {\n  position: relative;\n  width: 100%;\n  height: 100%;\n  overflow-y: auto;\n  overflow-x: visible;\n  overscroll-behavior: contain;\n  -webkit-overflow-scrolling: touch;\n  scroll-behavior: smooth;\n  -webkit-transform: translateZ(0);\n  transform: translateZ(0);\n  will-change: scroll-position;\n}\n\n.scroll-stack-inner {\n  padding: 20vh 5rem 50rem;\n  min-height: 100vh;\n}\n\n.scroll-stack-card-wrapper {\n  position: relative;\n}\n\n.scroll-stack-card {\n  transform-origin: top center;\n  will-change: transform, filter;\n  backface-visibility: hidden;\n  transform-style: preserve-3d;\n  box-shadow: 0 0 30px rgba(0, 0, 0, 0.1);\n  height: 20rem;\n  width: 100%;\n  margin: 30px 0;\n  padding: 3rem;\n  border-radius: 40px;\n  box-sizing: border-box;\n  /* Improve mobile performance */\n  -webkit-transform: translateZ(0);\n  transform: translateZ(0);\n  position: relative;\n}\n\n.scroll-stack-end {\n  width: 100%;\n  height: 1px;\n}\n",
      "type": "registry:item"
    }
  ]
}