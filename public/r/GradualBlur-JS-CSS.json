{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "GradualBlur-JS-CSS",
  "type": "registry:block",
  "title": "GradualBlur",
  "description": "Progressively un-blurs content based on scroll or trigger creating a cinematic reveal.",
  "dependencies": [
    "mathjs"
  ],
  "files": [
    {
      "path": "public/default/src/content/Animations/GradualBlur/GradualBlur.jsx",
      "content": "import React, { useEffect, useRef, useState, useMemo } from 'react';\nimport * as math from 'mathjs';\n\nimport './GradualBlur.css';\n\nconst DEFAULT_CONFIG = {\n  position: 'bottom',\n  strength: 2,\n  height: '6rem',\n  divCount: 5,\n  exponential: false,\n  zIndex: 1000,\n  animated: false,\n  duration: '0.3s',\n  easing: 'ease-out',\n  opacity: 1,\n  curve: 'linear',\n  responsive: false,\n  target: 'parent',\n  className: '',\n  style: {}\n};\n\nconst PRESETS = {\n  top: { position: 'top', height: '6rem' },\n  bottom: { position: 'bottom', height: '6rem' },\n  left: { position: 'left', height: '6rem' },\n  right: { position: 'right', height: '6rem' },\n  subtle: { height: '4rem', strength: 1, opacity: 0.8, divCount: 3 },\n  intense: { height: '10rem', strength: 4, divCount: 8, exponential: true },\n  smooth: { height: '8rem', curve: 'bezier', divCount: 10 },\n  sharp: { height: '5rem', curve: 'linear', divCount: 4 },\n  header: { position: 'top', height: '8rem', curve: 'ease-out' },\n  footer: { position: 'bottom', height: '8rem', curve: 'ease-out' },\n  sidebar: { position: 'left', height: '6rem', strength: 2.5 },\n  'page-header': { position: 'top', height: '10rem', target: 'page', strength: 3 },\n  'page-footer': { position: 'bottom', height: '10rem', target: 'page', strength: 3 }\n};\n\nconst CURVE_FUNCTIONS = {\n  linear: p => p,\n  bezier: p => p * p * (3 - 2 * p),\n  'ease-in': p => p * p,\n  'ease-out': p => 1 - Math.pow(1 - p, 2),\n  'ease-in-out': p => (p < 0.5 ? 2 * p * p : 1 - Math.pow(-2 * p + 2, 2) / 2)\n};\n\nconst mergeConfigs = (...configs) => configs.reduce((acc, c) => ({ ...acc, ...c }), {});\nconst getGradientDirection = position =>\n  ({\n    top: 'to top',\n    bottom: 'to bottom',\n    left: 'to left',\n    right: 'to right'\n  })[position] || 'to bottom';\n\nconst debounce = (fn, wait) => {\n  let t;\n  return (...a) => {\n    clearTimeout(t);\n    t = setTimeout(() => fn(...a), wait);\n  };\n};\n\nconst useResponsiveDimension = (responsive, config, key) => {\n  const [value, setValue] = useState(config[key]);\n  useEffect(() => {\n    if (!responsive) return;\n    const calc = () => {\n      const w = window.innerWidth;\n      let v = config[key];\n      if (w <= 480 && config[`mobile${key[0].toUpperCase() + key.slice(1)}`])\n        v = config[`mobile${key[0].toUpperCase() + key.slice(1)}`];\n      else if (w <= 768 && config[`tablet${key[0].toUpperCase() + key.slice(1)}`])\n        v = config[`tablet${key[0].toUpperCase() + key.slice(1)}`];\n      else if (w <= 1024 && config[`desktop${key[0].toUpperCase() + key.slice(1)}`])\n        v = config[`desktop${key[0].toUpperCase() + key.slice(1)}`];\n      setValue(v);\n    };\n    const debounced = debounce(calc, 100);\n    calc();\n    window.addEventListener('resize', debounced);\n    return () => window.removeEventListener('resize', debounced);\n  }, [responsive, config, key]);\n  return responsive ? value : config[key];\n};\n\nconst useIntersectionObserver = (ref, shouldObserve = false) => {\n  const [isVisible, setIsVisible] = useState(!shouldObserve);\n\n  useEffect(() => {\n    if (!shouldObserve || !ref.current) return;\n\n    const observer = new IntersectionObserver(([entry]) => setIsVisible(entry.isIntersecting), { threshold: 0.1 });\n\n    observer.observe(ref.current);\n    return () => observer.disconnect();\n  }, [ref, shouldObserve]);\n\n  return isVisible;\n};\n\nfunction GradualBlur(props) {\n  const containerRef = useRef(null);\n  const [isHovered, setIsHovered] = useState(false);\n\n  const config = useMemo(() => {\n    const presetConfig = props.preset && PRESETS[props.preset] ? PRESETS[props.preset] : {};\n    return mergeConfigs(DEFAULT_CONFIG, presetConfig, props);\n  }, [props]);\n\n  const responsiveHeight = useResponsiveDimension(config.responsive, config, 'height');\n  const responsiveWidth = useResponsiveDimension(config.responsive, config, 'width');\n\n  const isVisible = useIntersectionObserver(containerRef, config.animated === 'scroll');\n\n  const blurDivs = useMemo(() => {\n    const divs = [];\n    const increment = 100 / config.divCount;\n    const currentStrength =\n      isHovered && config.hoverIntensity ? config.strength * config.hoverIntensity : config.strength;\n\n    const curveFunc = CURVE_FUNCTIONS[config.curve] || CURVE_FUNCTIONS.linear;\n\n    for (let i = 1; i <= config.divCount; i++) {\n      let progress = i / config.divCount;\n      progress = curveFunc(progress);\n\n      let blurValue;\n      if (config.exponential) {\n        blurValue = math.pow(2, progress * 4) * 0.0625 * currentStrength;\n      } else {\n        blurValue = 0.0625 * (progress * config.divCount + 1) * currentStrength;\n      }\n\n      const p1 = math.round((increment * i - increment) * 10) / 10;\n      const p2 = math.round(increment * i * 10) / 10;\n      const p3 = math.round((increment * i + increment) * 10) / 10;\n      const p4 = math.round((increment * i + increment * 2) * 10) / 10;\n\n      let gradient = `transparent ${p1}%, black ${p2}%`;\n      if (p3 <= 100) gradient += `, black ${p3}%`;\n      if (p4 <= 100) gradient += `, transparent ${p4}%`;\n\n      const direction = getGradientDirection(config.position);\n\n      const divStyle = {\n        position: 'absolute',\n        inset: '0',\n        maskImage: `linear-gradient(${direction}, ${gradient})`,\n        WebkitMaskImage: `linear-gradient(${direction}, ${gradient})`,\n        backdropFilter: `blur(${blurValue.toFixed(3)}rem)`,\n        WebkitBackdropFilter: `blur(${blurValue.toFixed(3)}rem)`,\n        opacity: config.opacity,\n        transition:\n          config.animated && config.animated !== 'scroll'\n            ? `backdrop-filter ${config.duration} ${config.easing}`\n            : undefined\n      };\n\n      divs.push(<div key={i} style={divStyle} />);\n    }\n\n    return divs;\n  }, [config, isHovered]);\n\n  const containerStyle = useMemo(() => {\n    const isVertical = ['top', 'bottom'].includes(config.position);\n    const isHorizontal = ['left', 'right'].includes(config.position);\n    const isPageTarget = config.target === 'page';\n\n    const baseStyle = {\n      position: isPageTarget ? 'fixed' : 'absolute',\n      pointerEvents: config.hoverIntensity ? 'auto' : 'none',\n      opacity: isVisible ? 1 : 0,\n      transition: config.animated ? `opacity ${config.duration} ${config.easing}` : undefined,\n      zIndex: isPageTarget ? config.zIndex + 100 : config.zIndex,\n      ...config.style\n    };\n\n    if (isVertical) {\n      baseStyle.height = responsiveHeight;\n      baseStyle.width = responsiveWidth || '100%';\n      baseStyle[config.position] = 0;\n      baseStyle.left = 0;\n      baseStyle.right = 0;\n    } else if (isHorizontal) {\n      baseStyle.width = responsiveWidth || responsiveHeight;\n      baseStyle.height = '100%';\n      baseStyle[config.position] = 0;\n      baseStyle.top = 0;\n      baseStyle.bottom = 0;\n    }\n\n    return baseStyle;\n  }, [config, responsiveHeight, responsiveWidth, isVisible]);\n\n  const { hoverIntensity, animated, onAnimationComplete, duration } = config;\n\n  useEffect(() => {\n    if (isVisible && animated === 'scroll' && onAnimationComplete) {\n      const ms = parseFloat(duration) * 1000;\n      const t = setTimeout(() => onAnimationComplete(), ms);\n      return () => clearTimeout(t);\n    }\n  }, [isVisible, animated, onAnimationComplete, duration]);\n\n  return (\n    <div\n      ref={containerRef}\n      className={`gradual-blur ${config.target === 'page' ? 'gradual-blur-page' : 'gradual-blur-parent'} ${config.className}`}\n      style={containerStyle}\n      onMouseEnter={hoverIntensity ? () => setIsHovered(true) : undefined}\n      onMouseLeave={hoverIntensity ? () => setIsHovered(false) : undefined}\n    >\n      <div\n        className=\"gradual-blur-inner\"\n        style={{\n          position: 'relative',\n          width: '100%',\n          height: '100%'\n        }}\n      >\n        {blurDivs}\n      </div>\n    </div>\n  );\n}\n\nconst GradualBlurMemo = React.memo(GradualBlur);\nGradualBlurMemo.displayName = 'GradualBlur';\nGradualBlurMemo.PRESETS = PRESETS;\nGradualBlurMemo.CURVE_FUNCTIONS = CURVE_FUNCTIONS;\nexport default GradualBlurMemo;\n\nconst injectStyles = () => {\n  if (typeof document === 'undefined') return;\n\n  const styleId = 'gradual-blur-styles';\n  if (document.getElementById(styleId)) return;\n\n  const styleElement = document.createElement('style');\n  styleElement.id = styleId;\n  styleElement.textContent = `\n  .gradual-blur { pointer-events: none; transition: opacity 0.3s ease-out; }\n  .gradual-blur-parent { overflow: hidden; }\n  .gradual-blur-inner { pointer-events: none; }`;\n\n  document.head.appendChild(styleElement);\n};\n\nif (typeof document !== 'undefined') {\n  injectStyles();\n}\n",
      "type": "registry:component"
    },
    {
      "path": "public/default/src/content/Animations/GradualBlur/GradualBlur.css",
      "content": ".gradual-blur-inner {\n  position: relative;\n  width: 100%;\n  height: 100%;\n}\n\n.gradual-blur-inner > div {\n  -webkit-backdrop-filter: inherit;\n  backdrop-filter: inherit;\n}\n\n.gradual-blur {\n  isolation: isolate;\n}\n\n@supports not (backdrop-filter: blur(1px)) {\n  .gradual-blur-inner > div {\n    background: rgba(0, 0, 0, 0.3);\n    opacity: 0.5;\n  }\n}\n\n.gradual-blur-fixed {\n  position: fixed !important;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  pointer-events: none;\n  z-index: 1000;\n}\n",
      "type": "registry:item"
    }
  ]
}